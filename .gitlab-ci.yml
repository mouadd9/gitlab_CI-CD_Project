stages:
  - build # compile source code
  - test # unit + integration tests
  - security-analysis # This stage runs security and quality checks in parallel.
  - package-and-scan # # This stage packages your application into a Docker image and then scans that image for vulnerabilities.
  - publish # This final job pushes the verified and scanned Docker image to the GitLab Container Registry. It should typically only run on your main branch.
   #- deploy # traditional stage that deploys directly to clusters
  - gitops-update # triggers a deployment using a GitOps workflow with Flux.

workflow:
  rules:
    # Merge Request Pipeline (when merge request is submitted)
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    # Feature Branch Pipeline (when code is pushed to feature branch with no submitted MR)
    - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main" && $CI_PIPELINE_SOURCE == "push" && $CI_OPEN_MERGE_REQUESTS == null'
    # Main Branch Pipeline (when code is merged to main -> Deploys to Pre-Prod)
    - if: '$CI_COMMIT_BRANCH == "main"'
    # Production Branch Pipeline (when code is merged to production -> Deploys to Prod)
    - if: '$CI_COMMIT_BRANCH == "production"'
    # Rule 3: Run a pipeline if a tag is pushed.
    - if: '$CI_COMMIT_TAG'

# This job compiles code runs on all pipelines
build-job:
  stage: build
  image: eclipse-temurin:21-jdk
  script:
    - echo "Compiling code..."
    - ./mvnw clean compile
  artifacts:
    paths:
      - target/ # here we define which files to save, we save compiled code from the Runner's working directory.

# this job tests compiled code, runs on all pipelines
unit-and-integration-tests-job:
  stage: test
  image: eclipse-temurin:21-jdk 
  services:
    - docker:24-dind # this service provides the Docker daemon that the Docker CLI in your main container connects to, enabling you to build and manage containers within your CI/CD pipeline.
  variables:
    DOCKER_HOST: tcp://docker:2375 # Tell Testcontainers where to find the Docker daemon
  dependencies:
    - build-job   
  before_script:
    - apt-get update && apt-get install -y docker.io # we use this to install Docker CLI
  script:
    - echo "Running tests..."
    - ./mvnw test failsafe:integration-test
  artifacts:
    paths:
      - target/

# this job scans code for vulnerabilities and checks code quality runs on all pipelines
sonarqube-job: # this job should run on your local runner, because the sonarQube instance is running locally
  stage: security-analysis
  image: eclipse-temurin:21-jdk
  tags:
    - local-docker # the tag for the local runner that can connect to the local SonarQube
  dependencies:
    - unit-and-integration-tests-job # This job now depends on the test job to get the coverage reports
  script:
    - echo "Running SonarQube analysis..."
  #  - ./mvnw sonar:sonar -Dsonar.projectKey=my-springboot-project -Dsonar.host.url=http://sonarqube:9000 -Dsonar.login=$SONAR_TOKEN -Dsonar.qualitygate.wait=true -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml

# this job scans dependencies runs on all pipelines
trivy-dependency-scan-job:
  stage: security-analysis
  image: 
    name: aquasec/trivy:latest
    entrypoint: [""] 
  dependencies: []
  before_script:
    - trivy --version
  script:
    - echo "Scanning dependencies for vulnerabilities..."
    # Generate JSON report for GitLab Security Dashboard
    - trivy fs --format json --output trivy-report.json .
    # Run scan with table output and fail on HIGH/CRITICAL
    - trivy fs --exit-code 1 --severity HIGH,CRITICAL --format table .
  artifacts:
    paths:
      - trivy-report.json
  allow_failure: false

# this job packages code into a .jar, only runs when code is merged to the main
package-job: 
  stage: package-and-scan
  image: eclipse-temurin:21-jdk
  dependencies:
    - build-job
  script:
    - echo "Packaging application into JAR..."
    - ./mvnw package -DskipTests -DskipITs # package and skip tests
  artifacts: 
    paths:
      - target/*.jar # Save the JAR file for the next job
    exclude:
      - target/*original.jar
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# we only build and scan images when code is merged into main
build-image-job:
  stage: package-and-scan
  image: docker:24-cli # this image provides the Docker CLI
  services:
    - docker:24-dind # this service provides the Docker daemon for building images
  needs: 
    - job: package-job 
      artifacts: true # This job needs the JAR file from the package-job 
  script:
    - echo "Building Docker image with JAR file..."
    - docker build --tag my-app:$CI_COMMIT_SHORT_SHA .
    - echo "Saving Docker image as a .tar artifact..."
    - docker save my-app:$CI_COMMIT_SHORT_SHA -o my-image.tar
  artifacts:
    paths:
      - my-image.tar 
    expire_in: 1 hour
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# we only build and scan images in the Merge Request pipeline
scan-image-job:
  stage: package-and-scan
  image: docker:24-cli 
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    TRIVY_VERSION: '0.52.2'
  before_script:
    - apk add --no-cache curl
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v${TRIVY_VERSION}
  needs: 
    - job: build-image-job 
      artifacts: true 
  script:
    - echo "Loading Docker image from .tar artifact..."
    - docker load --input my-image.tar
    - echo "Scanning Docker image for vulnerabilities..."
    - trivy image --exit-code 1 --severity HIGH,CRITICAL my-app:$CI_COMMIT_SHORT_SHA
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# only runs after code is merged to main (ready for pre prod)
publish-job:
  stage: publish
  image: docker:24-cli
  services:
    - docker:24-dind
  dependencies:
    - build-image-job # This job depends on the build-image-job to get the Docker image
  script:
    - echo "Logging into GitLab Container Registry..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
    - echo "Loading Docker image from .tar artifact..."
    - docker load --input my-image.tar
    - echo "loaded image should be named my-app:$CI_COMMIT_SHORT_SHA"
    - echo "Tagging image with the link of the container registry of this project so that it can be pulled from the registry..."
    - docker tag my-app:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - docker tag my-app:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:latest
    - echo "listing images before pushing to inspect the tags and repositories..."
    - docker images
    - echo "Pushing image to $CI_REGISTRY_IMAGE and all its tags to the registry..."
    - docker push --all-tags $CI_REGISTRY_IMAGE
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'





# ////////////////////////////////////////////////////////// Legacy code
# ////////////////////////////////////////////////////////// Legacy code

# deploys code in a temporary environment to test the results of a feature before merging it to main
# only executed on merge requests
#deploy-review:
#  stage: deploy
#  # image: google/cloud-sdk:latest
#  environment:
#    name: review/$CI_COMMIT_REF_NAME
#    # url: https://staging.your-app.com
#    on_stop: stop-review # name of another job that should be run when the environment is "stopped."
#  script:
#    - echo "Deploying..."
#  rules:
#    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# this job is executed to clear out resources after a merge request is done
#stop-review:
#  stage: deploy
#  script:
#    - echo "Remove review app"
#    - echo "scripts to shut down servers, delete cloud resources, or perform other cleanup tasks to save costs"
#  environment:
#    name: review/$CI_COMMIT_REF_NAME
#    action: stop
#  rules:
#    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
#      when: manual


#deploy-staging:
#  stage: deploy
#  # This job needs an image with your cloud provider's CLI (e.g., kubectl, gcloud, aws)
#  # image: google/cloud-sdk:latest # Example for Google Kubernetes Engine
#  environment:
#    name: staging
#    # url: https://staging.your-app.com # URL to your staging environment
#  needs:
#    - job: publish-job
#      artifacts: false # We don't need artifacts, the image is in the registry
#  script:
#    - echo "Deploying to Staging Environment..."
#    # The actual deployment commands depend on your infrastructure (Kubernetes, VMs, etc.)
#    # Example for Kubernetes:
#    # - gcloud auth activate-service-account --key-file=$GCP_SA_KEY
#    # - gcloud container clusters get-credentials your-staging-cluster --region your-region
#    # - kubectl set image deployment/my-app my-app=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
#  rules:
#    # Run this job only for commits on the main branch
#    - if: '$CI_COMMIT_BRANCH == "main"'
#
#deploy-production:
#  stage: deploy
#  # This job needs an image with your cloud provider's CLI (e.g., kubectl, gcloud, aws)
#  # image: google/cloud-sdk:latest # Example for Google Kubernetes Engine
#  environment:
#    name: production
#    # url: https://your-app.com # URL to your live application
#  needs:
#    - job: publish-job
#      artifacts: false
#  script:
#    - echo "Deploying to Production Environment..."
#    # Use production-scoped CI/CD variables for credentials
#    # The image tag will be the git tag if available, otherwise the commit SHA
#    - |
#      if [[ -n "$CI_COMMIT_TAG" ]]; then
#        IMAGE_TAG="$CI_COMMIT_TAG"
#      else
#        IMAGE_TAG="$CI_COMMIT_SHORT_SHA"
#      fi
#    - echo "Deploying image $CI_REGISTRY_IMAGE:$IMAGE_TAG"
#    # - kubectl set image deployment/my-app my-app=$CI_REGISTRY_IMAGE:$IMAGE_TAG
#  rules:
#    # Allow manual deployment from the 'production' branch
#    # this checks if the code has been merged to a branch called production
#    - if: '$CI_COMMIT_BRANCH == "production"'
#      when: manual
#    # Allow manual deployment when a tag is created
#    - if: '$CI_COMMIT_TAG'
#      when: manual