workflow:
  rules:
    # Rule for Pipeline 1 & 2: Runs on merge requests
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    # Rule for Pipeline 3: Runs on merges to the main branch
    - if: '$CI_COMMIT_BRANCH == "main"'

stages:
  - security-scan
  - build
  - test
  - security-analysis
  - package-and-scan
  - publish
  - deploy

secret-detection:
  stage: security-scan
  image:
    name: "zricethezav/gitleaks:latest"
    entrypoint: [""]
  script:
    - gitleaks detect --no-git --verbose --report-path gitleaks-report.json
  artifacts:
    paths:
      - gitleaks-report.json
  # This job runs in all pipelines (Draft MR, Ready MR, Main branch)
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# This job compiles code runs on all pipelines
compile-code:
  stage: build
  image: eclipse-temurin:21-jdk
  script:
    - echo "Compiling code..."
    - ./mvnw clean compile
  artifacts:
    paths:
      - target/
    expire_in: 30 minutes
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

unit-tests:
  stage: test
  image: eclipse-temurin:21-jdk
  needs:
    - compile-code
  script:
    - ./mvnw test
  artifacts:
    reports:
      junit:
        - target/surefire-reports/TEST-*.xml
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# this job tests compiled code, runs on all pipelines
integration-tests:
  stage: test
  image: eclipse-temurin:21-jdk
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
  needs:
    - compile-code
  script:
    - ./mvnw failsafe:integration-test
  #  only for "Ready" MRs and main branch pipelines
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_DRAFT == "false"'

# this job scans code for vulnerabilities and checks code quality runs on all pipelines
sonarqube-job: # this job should run on your local runner, because the sonarQube instance is running locally
  stage: security-analysis
  image: eclipse-temurin:21-jdk
  tags:
    - local-docker # the tag for the local runner that can connect to the local SonarQube
  dependencies:
    - unit-tests # This job now depends on the test job to get the coverage reports
  script:
    - echo "Running SonarQube analysis..."
    - ./mvnw sonar:sonar -Dsonar.projectKey=my-springboot-project -Dsonar.host.url=http://sonarqube:9000 -Dsonar.login=$SONAR_TOKEN -Dsonar.qualitygate.wait=true -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when : never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_DRAFT == "false"'
      when : never

# test
# this job scans dependencies runs on all pipelines
trivy-dependency-scan-job:
  stage: security-analysis
  image: 
    name: aquasec/trivy:latest
    entrypoint: [""] 
  dependencies: []
  before_script:
    - trivy --version
  script:
    - echo "Scanning dependencies for vulnerabilities..."
    # Generate JSON report for GitLab Security Dashboard
    - trivy fs --format json --output trivy-report.json .
    # Run scan with table output and fail on HIGH/CRITICAL
    - trivy fs --exit-code 1 --severity HIGH,CRITICAL --format table .
  artifacts:
    paths:
      - trivy-report.json
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_DRAFT == "false"'

# this job packages code into a .jar, only runs when code is merged to the main
package-job: 
  stage: package-and-scan
  image: eclipse-temurin:21-jdk
  dependencies:
    - compile-code
  script:
    - echo "Packaging application into JAR..."
    - ./mvnw package -DskipTests -DskipITs # package and skip tests
  artifacts: 
    paths:
      - target/*.jar # Save the JAR file for the next job
    exclude:
      - target/*original.jar
    expire_in: 1 hour
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# we only build and scan images when code is merged into main
build-image-job:
  stage: package-and-scan
  image: docker:24-cli # this image provides the Docker CLI
  services:
    - docker:24-dind # this service provides the Docker daemon for building images
  needs: 
    - job: package-job 
      artifacts: true # This job needs the JAR file from the package-job 
  script:
    - echo "Building Docker image with JAR file..."
    - docker build --tag my-app:$CI_COMMIT_SHORT_SHA .
    - echo "Saving Docker image as a .tar artifact..."
    - docker save my-app:$CI_COMMIT_SHORT_SHA -o my-image.tar
  artifacts:
    paths:
      - my-image.tar 
    expire_in: 1 hour
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# we only build and scan images if code is merged into main
scan-image-job:
  stage: package-and-scan
  image: docker:24-cli 
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    TRIVY_VERSION: '0.52.2'
  before_script:
    - apk add --no-cache curl
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v${TRIVY_VERSION}
  needs:
    - job: build-image-job
      artifacts: true 
  script:
    - echo "Loading Docker image from .tar artifact..."
    - docker load --input my-image.tar
    - echo "Scanning Docker image for vulnerabilities..."
    - trivy image --exit-code 1 --severity HIGH,CRITICAL my-app:$CI_COMMIT_SHORT_SHA
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# only runs after code is merged to main (ready for pre prod)
publish-container-image:
  stage: publish
  image: docker:24-cli
  services:
    - docker:24-dind
  needs:
    - job: build-image-job
      artifacts: true    # Only get my-image.tar
    - job: scan-image-job # Wait for scan to complete, but no artifacts
      artifacts: false   # Don't download scan artifacts
  script:
    - echo "Logging into GitLab Container Registry..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
    - echo "Loading Docker image from .tar artifact..."
    - docker load --input my-image.tar
    - echo "loaded image should be named my-app:$CI_COMMIT_SHORT_SHA"
    - echo "Tagging image with the link of the container registry of this project so that it can be pulled from the registry..."
    - docker tag my-app:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - docker tag my-app:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:latest
    - echo "listing images before pushing to inspect the tags and repositories..."
    - docker images
    - echo "Pushing image to $CI_REGISTRY_IMAGE and all its tags to the registry..."
    - docker push --all-tags $CI_REGISTRY_IMAGE
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

deploy-to-staging:
  stage: deploy
  image:
    name: alpine/git:latest
    entrypoint: [""]
  needs:
    - job: publish-container-image
      artifacts: false
  before_script:
    - apk add --no-cache curl # Install curl to download yq
    - curl -L https://github.com/mikefarah/yq/releases/download/v4.35.1/yq_linux_amd64 -o /usr/bin/yq # The server sends back a binary file in the HTTP response body
    - chmod +x /usr/bin/yq # Make the yq binary executable
    - git config --global user.email "pipeline@mycompany.com"
    - git config --global user.name "GitLab Pipeline"
    - echo "Cloning GitOps repository..."
    - git clone https://pipeline:${GITOPS_REPO_TOKEN}@gitlab.com/mouadd9/gitops-infra-repo
  script:
    - cd gitops-infra-repo
    - yq eval '.image.tag = "'$CI_COMMIT_SHORT_SHA'"' -i environments/values-staging.yaml
    - git add .
    - |
      git commit -m "Deploy version $CI_COMMIT_SHORT_SHA
      Image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
      Pipeline: $CI_PIPELINE_URL"
    - git push
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
