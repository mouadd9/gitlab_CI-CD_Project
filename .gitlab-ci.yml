stages:
  - build # compile source code
  - test # unit + integration tests
  - security-analysis # This stage runs security and quality checks in parallel.
  - package-and-scan # # This stage packages your application into a Docker image and then scans that image for vulnerabilities.
  - publish # This final job pushes the verified and scanned Docker image to the GitLab Container Registry. It should typically only run on your main branch.
  - deploy # triggers a deployment using a GitOps workflow with Flux.

workflow:
  rules:
    # Merge Request Pipeline (when merge request is submitted)
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    # Feature Branch Pipeline (when code is pushed to feature branch with no submitted MR)
    - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main" && $CI_PIPELINE_SOURCE == "push" && $CI_OPEN_MERGE_REQUESTS == null'
    # Main Branch Pipeline (when code is merged to main -> Deploys to Pre-Prod)
    - if: '$CI_COMMIT_BRANCH == "main"'
    # Production Branch Pipeline (when code is merged to production -> Deploys to Prod)
    - if: '$CI_COMMIT_BRANCH == "production"'
    # Rule 3: Run a pipeline if a tag is pushed.
    - if: '$CI_COMMIT_TAG'

# This job compiles code runs on all pipelines
build-job:
  stage: build
  image: eclipse-temurin:21-jdk
  script:
    - echo "Compiling code..."
    - ./mvnw clean compile
  artifacts:
    paths:
      - target/ # here we define which files to save, we save compiled code from the Runner's working directory.

# this job tests compiled code, runs on all pipelines
unit-and-integration-tests-job:
  stage: test
  image: eclipse-temurin:21-jdk 
  services:
    - docker:24-dind # this service provides the Docker daemon that the Docker CLI in your main container connects to, enabling you to build and manage containers within your CI/CD pipeline.
  variables:
    DOCKER_HOST: tcp://docker:2375 # Tell Testcontainers where to find the Docker daemon
  dependencies:
    - build-job   
  before_script:
    - apt-get update && apt-get install -y docker.io # we use this to install Docker CLI
  script:
    - echo "Running tests..."
    - ./mvnw test failsafe:integration-test
  artifacts:
    paths:
      - target/

# this job scans code for vulnerabilities and checks code quality runs on all pipelines
sonarqube-job: # this job should run on your local runner, because the sonarQube instance is running locally
  stage: security-analysis
  image: eclipse-temurin:21-jdk
  tags:
    - local-docker # the tag for the local runner that can connect to the local SonarQube
  dependencies:
    - unit-and-integration-tests-job # This job now depends on the test job to get the coverage reports
  script:
    - echo "Running SonarQube analysis..."
  #  - ./mvnw sonar:sonar -Dsonar.projectKey=my-springboot-project -Dsonar.host.url=http://sonarqube:9000 -Dsonar.login=$SONAR_TOKEN -Dsonar.qualitygate.wait=true -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml
  rules:
    - when: never

# this job scans dependencies runs on all pipelines
trivy-dependency-scan-job:
  stage: security-analysis
  image: 
    name: aquasec/trivy:latest
    entrypoint: [""] 
  dependencies: []
  before_script:
    - trivy --version
  script:
    - echo "Scanning dependencies for vulnerabilities..."
    # Generate JSON report for GitLab Security Dashboard
    - trivy fs --format json --output trivy-report.json .
    # Run scan with table output and fail on HIGH/CRITICAL
    - trivy fs --exit-code 1 --severity HIGH,CRITICAL --format table .
  artifacts:
    paths:
      - trivy-report.json

# this job packages code into a .jar, only runs when code is merged to the main
package-job: 
  stage: package-and-scan
  image: eclipse-temurin:21-jdk
  dependencies:
    - build-job
  script:
    - echo "Packaging application into JAR..."
    - ./mvnw package -DskipTests -DskipITs # package and skip tests
  artifacts: 
    paths:
      - target/*.jar # Save the JAR file for the next job
    exclude:
      - target/*original.jar
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# we only build and scan images when code is merged into main
build-image-job:
  stage: package-and-scan
  image: docker:24-cli # this image provides the Docker CLI
  services:
    - docker:24-dind # this service provides the Docker daemon for building images
  needs: 
    - job: package-job 
      artifacts: true # This job needs the JAR file from the package-job 
  script:
    - echo "Building Docker image with JAR file..."
    - docker build --tag my-app:$CI_COMMIT_SHORT_SHA .
    - echo "Saving Docker image as a .tar artifact..."
    - docker save my-app:$CI_COMMIT_SHORT_SHA -o my-image.tar
  artifacts:
    paths:
      - my-image.tar 
    expire_in: 1 hour
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# we only build and scan images in the Merge Request pipeline
scan-image-job:
  stage: package-and-scan
  image: docker:24-cli 
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    TRIVY_VERSION: '0.52.2'
  before_script:
    - apk add --no-cache curl
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v${TRIVY_VERSION}
  needs: 
    - job: build-image-job 
      artifacts: true 
  script:
    - echo "Loading Docker image from .tar artifact..."
    - docker load --input my-image.tar
    - echo "Scanning Docker image for vulnerabilities..."
    - trivy image --exit-code 1 --severity HIGH,CRITICAL my-app:$CI_COMMIT_SHORT_SHA
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# After your existing package-job
package-helm-chart:
  stage: package-and-scan
  image: alpine/helm:latest
  dependencies: []
  script:
    - echo "Packaging Helm chart..."
    - cd helm-chart/
    # --version $CI_COMMIT_SHORT_SHA : sets the chart's own version number.
    # --app-version $CI_COMMIT_SHORT_SHA : sets the appVersion inside the Chart.yaml file. This field indicates the version of the application being deployed. Using the commit ID for both makes it very easy to trace a deployed package directly back to the exact code it was built from.
    - helm package . --version $CI_COMMIT_SHORT_SHA --app-version $CI_COMMIT_SHORT_SHA
    - echo "Chart packaged as helm-chart-$CI_COMMIT_SHORT_SHA.tgz"
  artifacts:
    paths: # tells GitLab to find the newly created .tgz file inside the helm-chart directory and save it as a job artifact
      - helm-chart/*.tgz
    expire_in: 1 hour
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# only runs after code is merged to main (ready for pre prod)
publish-container-image:
  stage: publish
  image: docker:24-cli
  services:
    - docker:24-dind
  dependencies:
    - build-image-job # This job depends on the build-image-job to get the Docker image
  before_script:
    - echo "Logging into GitLab Container Registry..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
  script:
    - echo "Loading Docker image from .tar artifact..."
    - docker load --input my-image.tar
    - echo "loaded image should be named my-app:$CI_COMMIT_SHORT_SHA"
    - echo "Tagging image with the link of the container registry of this project so that it can be pulled from the registry..."
    - docker tag my-app:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - docker tag my-app:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:latest
    - echo "listing images before pushing to inspect the tags and repositories..."
    - docker images
    - echo "Pushing image to $CI_REGISTRY_IMAGE and all its tags to the registry..."
    - docker push --all-tags $CI_REGISTRY_IMAGE
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

publish-helm-chart:
  stage: publish
  image: alpine/helm:latest
  dependencies:
    - package-helm-chart
  before_script:
    - echo "Logging into GitLab Container Registry for Helm charts..."
    - echo "$CI_REGISTRY_PASSWORD" | helm registry login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
  script:
    - echo "Pushing Helm chart to registry..."
    - helm push helm-chart/*.tgz oci://$CI_REGISTRY/$CI_PROJECT_PATH
    - echo "âœ… Chart pushed successfully!"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

update-gitops-repo:
  stage: deploy
  image: alpine/git:latest
  script:
    - apk add --no-cache curl # Install curl to download yq
    - curl -L https://github.com/mikefarah/yq/releases/download/v4.35.1/yq_linux_amd64 -o /usr/bin/yq # The server sends back a binary file in the HTTP response body
    - chmod +x /usr/bin/yq # Make the yq binary executable
    - git config --global user.email "pipeline@mycompany.com"
    - git config --global user.name "GitLab Pipeline"
    - echo "Cloning GitOps repository..."
    - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/mouadd9/gitops-infra-repo
    - cd gitops-infra-repo
    - echo "Updating Helm chart version in GitOps repository..."
    - yq eval '.spec.sources[0].targetRevision = "'$CI_COMMIT_SHORT_SHA'"' -i applications/app-staging.yaml
    - yq eval '.image.tag = "'$CI_COMMIT_SHORT_SHA'"' -i environments/values-staging.yaml
    - git add .
    - |
      git commit -m "Deploy version $CI_COMMIT_SHORT_SHA
      Image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
      Chart: oci://$CI_REGISTRY/$CI_PROJECT_PATH/helm-chart:$CI_COMMIT_SHORT_SHA
      Pipeline: $CI_PIPELINE_URL"
    - git push
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
