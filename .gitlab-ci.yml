stages:
  - build # compile source code
  - test # unit + integration tests
  - security-analysis # This stage runs security and quality checks in parallel.
  - package-and-scan # # This stage packages your application into a Docker image and then scans that image for vulnerabilities.
  - publish # This final job pushes the verified and scanned Docker image to the GitLab Container Registry. It should typically only run on your main branch.

# This job compiles code and generates /target folder that contains byte code
build-job:
  stage: build
  image: eclipse-temurin:21-jdk
  script:
    - echo "Compiling code..."
    - ./mvnw clean compile
  artifacts:
    paths:
      - target/ # here we define which files to save, we save compiled code from the Runner's working directory.

unit-and-integration-tests-job:
  stage: test
  image: eclipse-temurin:21-jdk 
  services:
    - docker:24-dind # this service provides the Docker daemon that the Docker CLI in your main container connects to, enabling you to build and manage containers within your CI/CD pipeline.
  variables:
    DOCKER_HOST: tcp://docker:2375 # Tell Testcontainers where to find the Docker daemon
  dependencies:
    - build-job   
  before_script:
    - apt-get update && apt-get install -y docker.io # we use this to install Docker CLI
  script:
    - echo "Running tests..."
    - ./mvnw test failsafe:integration-test
  artifacts:
    paths:
      - target/

sonarqube-job: # this job should run on your local runner, because the sonarQube instance is running locally
  stage: security-analysis
  image: eclipse-temurin:21-jdk
  tags:
    - local-docker # the tag for the local runner that can connect to the local SonarQube
  dependencies:
    - unit-and-integration-tests-job # This job now depends on the test job to get the coverage reports
  script:
    - echo "Running SonarQube analysis..."
    - ./mvnw sonar:sonar -Dsonar.projectKey=my-springboot-project -Dsonar.host.url=http://sonarqube:9000 -Dsonar.login=$SONAR_TOKEN -Dsonar.qualitygate.wait=true -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml

trivy-dependency-scan-job:
  stage: security-analysis
  image: aquasec/trivy:latest
  script:
    - echo "Scanning dependencies for vulnerabilities..."
    # Scans the filesystem, finds the pom.xml, and fails on high/critical issues
    - trivy fs --exit-code 1 --severity HIGH,CRITICAL .

package-job: 
  stage: package-and-scan
  image: eclipse-temurin:21-jdk
  dependencies:
    - build-job
  script:
    - echo "Packaging application into JAR..."
    - ./mvnw package -DskipTests -DskipITs # package and skip tests
  artifacts: 
    paths:
      - target/*.jar # Save the JAR file for the next job
    exclude:
      - target/*original.jar

build-image-job:
  stage: package-and-scan
  image: docker:24-cli # this image provides the Docker CLI
  services:
    - docker:24-dind # this service provides the Docker daemon for building images
  needs: 
    - job: package-job 
      artifacts: true # This job needs the JAR file from the package-job 
  script:
    - echo "Building Docker image with JAR file..."
    - docker build --tag my-app:$CI_COMMIT_SHORT_SHA .
    - echo "Saving Docker image as a .tar artifact..."
    - docker save my-app:$CI_COMMIT_SHORT_SHA -o my-image.tar
  artifacts:
    paths:
      - my-image.tar 
    expire_in: 1 hour
       
scan-image-job:
  stage: package-and-scan
  image: docker:24-cli 
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    TRIVY_VERSION: '0.52.2'
  before_script:
    - apk add --no-cache curl
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v${TRIVY_VERSION}
  needs: 
    - job: build-image-job 
      artifacts: true 
  script:
    - echo "Loading Docker image from .tar artifact..."
    - docker load --input my-image.tar
    - echo "Scanning Docker image for vulnerabilities..."
    - trivy image --exit-code 1 --severity HIGH,CRITICAL my-app:$CI_COMMIT_SHORT_SHA

publish-job:
  stage: publish
  image: docker:24-cli
  services:
    - docker:24-dind
  dependencies:
    - build-image-job # This job depends on the build-image-job to get the Docker image
  script:
    - echo "Logging into GitLab Container Registry..."
    # the Docker client should be able to authenticatewith a container registry in order for it to push images
    # outside of Gitlab CI/CD, you would typically use a Docker login command with your credentials
    # docker login registry.example.com -u <username> -p <password>
    # but now we use the GitLab predefined variables to log in, 
    # CI_REGISTRY_USER holds a per-job user with read-write access to the container registry
    # Its password is also automatically created and available in CI_REGISTRY_PASSWORD
    # $CI_REGISTRY This is the address of the Docker registry you are logging into. GitLab sets this predefined variable to the URL of your instance's container registry 
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
    - echo "Loading Docker image from .tar artifact..."
    - docker load --input my-image.tar
    - echo "loaded image should be named my-app:$CI_COMMIT_SHORT_SHA"
    - echo "repository:my-app version:$CI_COMMIT_SHORT_SHA" # a repository is a collection of different versions of a single Docker image
    - docker images # List all Docker images to verify the image is loaded
    
    # we rename the image to include the registry URL
    - echo "Tagging image for the registry..." # a registry is a collection of repositories, each repository contains different versions of a single Docker image 
    - docker tag my-app:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - docker tag my-app:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:latest

    - echo "listing images before pushing to inspect the tags and repositories..."
    - docker images

    - echo "Pushing image $CI_REGISTRY_IMAGE and all its tags to the registry..."
    - docker push --all-tags $CI_REGISTRY_IMAGE # we push all tags of the image 
  rules:
    # Only run this job for commits to the main branch
    - if: '$CI_COMMIT_BRANCH == "main"'
